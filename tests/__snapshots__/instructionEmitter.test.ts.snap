// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`instructionEmitter > creates batch package snapshot 1`] = `
{
  "constraints": [
    {
      "constraintId": "domain-no-imports-from-app-or-infra",
      "detectionSteps": [
        "Enumerate every file under /domain/ excluding ignored paths.",
        "Parse and classify each import specifier relative to the current file.",
        "Record an initial violation whenever the resolved layer is app or infra.",
      ],
      "enforcementOrder": 1,
      "fixStrategy": "Determine whether the import is orchestration or infrastructural.",
      "objective": "Domain layer MUST NOT import code from app or infra layers.",
      "passCriteria": "violations list empty after final pass.; Each initial violation referenced in fixes_applied.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line",
        "specifier",
        "resolved_layer",
      ],
      "selfVerificationChecklist": [
        "No domain file imports from '/app/' or '/infra/'.",
        "Newly added files continue to satisfy single-responsibility and max-file-lines.",
      ],
    },
    {
      "constraintId": "app-no-imports-from-infra",
      "detectionSteps": [
        "Collect every /app/ file except ignored paths.",
        "Parse import statements and classify their resolved layer.",
        "Emit violations for any import mapped to infra.",
      ],
      "enforcementOrder": 2,
      "fixStrategy": "Identify the concrete capability pulled from infra (database access, queue, etc.).",
      "objective": "Application layer MUST NOT depend directly on infrastructure implementations.",
      "passCriteria": "No app file imports infra modules.; fixes_applied references each original violation.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line",
        "specifier",
        "resolved_layer",
      ],
      "selfVerificationChecklist": [
        "App layer depends only on domain + external packages.",
        "Any required infra capability exposed through a facade or service interface.",
      ],
    },
    {
      "constraintId": "domain-no-side-effects",
      "detectionSteps": [
        "Enumerate domain files.",
        "Scan call expressions for known side-effect APIs (fs, process, console, timers, randomness).",
        "Detect mutable globals or clock access performed without injection.",
      ],
      "enforcementOrder": 3,
      "fixStrategy": "Classify violation as IO, logging, timing, randomness, or global mutation.",
      "objective": "Domain logic MUST remain deterministic and side-effect free.",
      "passCriteria": "violations list empty.; Domain files only depend on injected collaborators for side effects.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line",
        "expression",
        "reason",
      ],
      "selfVerificationChecklist": [
        "Each side-effectful concern lives in app or infra.",
        "Domain tests run deterministically without stubs that hit IO.",
      ],
    },
    {
      "constraintId": "max-file-lines",
      "detectionSteps": [
        "List all .ts/.tsx files under src excluding ignored directories.",
        "Count logical (non-comment, non-blank) lines for each file.",
        "Record files whose counts exceed 300 lines.",
      ],
      "enforcementOrder": 4,
      "fixStrategy": "Identify cohesive responsibilities within the oversized file.",
      "objective": "All implementation files MUST remain at or below 300 logical lines.",
      "passCriteria": "No files exceed 300 logical lines.; Each extracted module honors single-responsibility and export limits.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line_start",
        "line_end",
        "logical_line_count",
      ],
      "selfVerificationChecklist": [
        "Each new file reports <= 300 logical lines.",
        "Unit tests reference new modules instead of the old monolith.",
      ],
    },
    {
      "constraintId": "single-responsibility",
      "detectionSteps": [
        "Enumerate .ts/.tsx files under src.",
        "Parse every export (functions, classes, consts, types) plus inferred category.",
        "Flag files exceeding three exports or mixing multiple responsibility categories.",
      ],
      "enforcementOrder": 5,
      "fixStrategy": "Identify the core responsibility represented by the file.",
      "objective": "Each implementation file MUST focus on a single responsibility with minimal exports.",
      "passCriteria": "export_count <= 3 for every file.; All exports in a file share the same responsibility_category.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "export_count",
        "primary_category",
        "extra_exports",
      ],
      "selfVerificationChecklist": [
        "Each new file name reflects its responsibility.",
        "Barrel files do not reintroduce excessive exports via wildcard spreads.",
      ],
    },
    {
      "constraintId": "excessive-nesting",
      "detectionSteps": [
        "Enumerate .ts/.tsx files.",
        "Parse each function/method body and compute maximum block depth.",
        "Report functions whose max_nesting exceeds 3.",
      ],
      "enforcementOrder": 6,
      "fixStrategy": "Identify decision points contributing to depth.",
      "objective": "Control flow nesting depth MUST NOT exceed 3 levels in any function.",
      "passCriteria": "max_nesting <= 3 for all functions.; Extracted helpers remain within single-responsibility bounds.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "function_name",
        "max_nesting",
        "line_start",
        "line_end",
      ],
      "selfVerificationChecklist": [
        "Guard clauses cover invalid states early.",
        "Complex workflows are documented with sequence diagrams or ADRs when needed.",
      ],
    },
    {
      "constraintId": "file-naming",
      "detectionSteps": [
        "List all files under src excluding ignored directories.",
        "Infer expected naming pattern (kebab vs Pascal) per file type.",
        "Flag file names that do not match the expected pattern.",
      ],
      "enforcementOrder": 7,
      "fixStrategy": "Determine the correct case rule for the file (kebab or Pascal).",
      "objective": "File names MUST follow deterministic casing rules by layer and artifact type.",
      "passCriteria": "All \`.ts\` files use kebab-case (plus optional \`.spec\`/\`.test\` suffix).; All \`.tsx\` component files use PascalCase.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "actual_name",
        "expected_pattern",
        "reason",
      ],
      "selfVerificationChecklist": [
        "\`git status --short\` shows the rename operation on case-sensitive systems.",
        "Storybook or routing metadata updated to reflect new casing when needed.",
      ],
    },
    {
      "constraintId": "folder-naming",
      "detectionSteps": [
        "Enumerate every directory under src (excluding ignored paths).",
        "Validate each basename against kebab-case unless reserved root.",
        "Detect case-collision groups that differ only by casing.",
      ],
      "enforcementOrder": 8,
      "fixStrategy": "Rename offending folders to kebab-case (lowercase words separated by dashes).",
      "objective": "Directory names MUST follow deterministic kebab-case conventions to avoid ambiguity on case-sensitive systems.",
      "passCriteria": "All non-reserved directories are kebab-case.; No case-collision duplicates remain.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "folder_path",
        "actual_name",
        "expected_pattern",
      ],
      "selfVerificationChecklist": [
        "\`git status\` shows directory renames tracked correctly.",
        "Path aliases (tsconfig paths, webpack) reflect the new casing.",
      ],
    },
    {
      "constraintId": "mvc-layer-separation",
      "detectionSteps": [
        "Ensure controller, model, and view layers each contain at least one implementation file; record missing-layer violations before deeper analysis.",
        "Enumerate controller files, parse imports, and flag data-access-api usage or direct imports from '/views/'.",
        "Enumerate model files and flag imports referencing controllers or views.",
        "Enumerate view files and flag occurrences of data-access-api usage or business logic keywords (calculations, validation, repository calls).",
        "Aggregate every breach into violations_mvc with precise line numbers and context details.",
      ],
      "enforcementOrder": 9,
      "fixStrategy": "Scaffold missing MVC layers so controllers, models, and views each have concrete implementations.",
      "objective": "Ensure Model-View-Controller responsibilities remain isolated so controllers orchestrate requests, models encapsulate domain logic, and views render presentation only.",
      "passCriteria": "violations_mvc array is empty after remediation; Controllers, models, and views layers each contain at least one implementation file; Controllers contain orchestration only (no data-access-api usage remains); Views contain presentation logic only; revalidated_zero equals true",
      "reportFields": [
        "constraint_id",
        "layer",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Controllers delegate domain logic to models or services and select views via contracts",
        "Models expose domain methods consumed by controllers without referencing views",
        "Views render data passed by controllers without side effects or persistence",
      ],
    },
    {
      "constraintId": "mvp-presenter-boundaries",
      "detectionSteps": [
        "Ensure presenter, view, and model layers exist and contain implementations; emit missing-layer violations when absent.",
        "List presenter files and inspect constructor dependencies for concrete view classes; flag when no view-interface or inversion present.",
        "Inspect presenter files to ensure they export interfaces or types for views to implement.",
        "Scan view files for imports from models or presenters and for stateful-logic occurrences.",
        "Inspect model files to confirm they do not import presenters or views.",
      ],
      "enforcementOrder": 10,
      "fixStrategy": "Create or restore presenter, view, and model layers with concrete implementations and shared contracts.",
      "objective": "Maintain clear separation between Model-View-Presenter responsibilities so presenters coordinate state, views handle rendering, and models encapsulate data logic without cross-layer leakage.",
      "passCriteria": "violations_mvp array empty; Presenter, view, and model layers contain at least one implementation file each; All presenter dependencies on views go through interfaces or injected callbacks; Every presenter exposes a view-interface contract implemented by the view layer; Views contain only rendering logic and event wiring; revalidated_zero equals true",
      "reportFields": [
        "constraint_id",
        "layer",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Presenters own state management, orchestrating models and pushing updates to views via interfaces",
        "Views implement interfaces, trigger callbacks, and avoid domain decisions",
        "Models stay independent from presenters and views",
      ],
    },
    {
      "constraintId": "mvvm-binding-integrity",
      "detectionSteps": [
        "Ensure viewmodel, view, and model layers each contain implementation files; record missing-layer violations when absent.",
        "Parse view model files to confirm imports exclude views, UI-thread-api, or DOM manipulation libraries.",
        "Inspect views to confirm bindings to viewmodels, flagging missing bindings, direct state mutation, or business logic/persistence.",
        "Inspect model files to ensure they do not import viewmodels or views.",
      ],
      "enforcementOrder": 11,
      "fixStrategy": "Create or restore viewmodel, view, and model layers with concrete MVVM implementations and bindings.",
      "objective": "Guarantee Model-View-ViewModel boundaries by enforcing one-way dependencies, keeping view models free of view references, and ensuring views bind without business logic.",
      "passCriteria": "violations_mvvm array empty; Viewmodel, view, and model layers each contain at least one implementation file; Every view binds to a viewmodel through declarative bindings or exposed commands; View models depend only on models/shared utilities, never on views or UI APIs; Views bind declaratively without business logic or direct state mutation; revalidated_zero equals true",
      "reportFields": [
        "constraint_id",
        "layer",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "View models expose state and commands independent of UI frameworks",
        "Views bind to viewmodel state and trigger commands without domain logic",
        "Models remain UI-agnostic and interact only with domain concerns",
      ],
    },
  ],
  "ignoredPaths": [
    "node_modules",
    "dist",
    "build",
    ".git",
  ],
  "mode": "batch",
  "recommendedOrder": [
    "domain-no-imports-from-app-or-infra",
    "app-no-imports-from-infra",
    "domain-no-side-effects",
    "max-file-lines",
    "single-responsibility",
    "excessive-nesting",
    "file-naming",
    "folder-naming",
    "mvc-layer-separation",
    "mvp-presenter-boundaries",
    "mvvm-binding-integrity",
  ],
  "reportTemplate": {
    "agentExecutionSignature": null,
    "analysisPerformed": false,
    "completionTimestamp": null,
    "constraintBlocksReceived": 11,
    "enumeratedFilesCount": 0,
    "executionState": "unvalidated",
    "fixesApplied": [],
    "initialViolationCount": 0,
    "postFixStatus": {
      "remainingViolations": 0,
      "revalidated": false,
    },
    "remainingViolationCount": 0,
    "reportKind": "cda_validation_result",
    "revalidationAttemptsUsed": 0,
    "runId": "snapshot-run",
    "selfAudit": {
      "allConstraintsPresent": false,
      "allRequiredFieldsPopulated": false,
      "revalidationAttemptsDocumented": false,
      "schemaConformance": false,
    },
    "status": null,
    "successConditions": {
      "allConstraintsEvaluated": false,
      "noRemainingViolations": false,
    },
    "summary": {
      "analyzedFiles": 0,
      "constraintsEvaluated": 11,
      "totalViolations": 0,
    },
    "violations": [],
  },
  "runId": "snapshot-run",
}
`;

exports[`instructionEmitter > creates single package snapshot 1`] = `
{
  "constraint": {
    "constraintId": "domain-no-imports-from-app-or-infra",
    "detectionSteps": [
      "Enumerate every file under /domain/ excluding ignored paths.",
      "Parse and classify each import specifier relative to the current file.",
      "Record an initial violation whenever the resolved layer is app or infra.",
    ],
    "enforcementOrder": 1,
    "fixStrategy": "Determine whether the import is orchestration or infrastructural.",
    "objective": "Domain layer MUST NOT import code from app or infra layers.",
    "passCriteria": "violations list empty after final pass.; Each initial violation referenced in fixes_applied.; revalidated_zero equals true.",
    "reportFields": [
      "constraint_id",
      "file_path",
      "line",
      "specifier",
      "resolved_layer",
    ],
    "selfVerificationChecklist": [
      "No domain file imports from '/app/' or '/infra/'.",
      "Newly added files continue to satisfy single-responsibility and max-file-lines.",
    ],
  },
  "mode": "single",
  "reportTemplate": {
    "agentExecutionSignature": null,
    "analysisPerformed": false,
    "completionTimestamp": null,
    "constraintBlocksReceived": 1,
    "constraintId": "domain-no-imports-from-app-or-infra",
    "enumeratedFilesCount": 0,
    "executionState": "unvalidated",
    "fixesApplied": [],
    "initialViolationCount": 0,
    "postFixStatus": {
      "remainingViolations": 0,
      "revalidated": false,
    },
    "remainingViolationCount": 0,
    "reportKind": "cda_single_constraint_validation_result",
    "revalidationAttemptsUsed": 0,
    "runId": "snapshot-run",
    "selfAudit": {
      "allConstraintsPresent": false,
      "allRequiredFieldsPopulated": false,
      "revalidationAttemptsDocumented": false,
      "schemaConformance": false,
    },
    "status": null,
    "successConditions": {
      "allConstraintsEvaluated": false,
      "noRemainingViolations": false,
    },
    "violations": [],
  },
  "runId": "snapshot-run",
}
`;
