// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`instructionEmitter > creates batch package snapshot 1`] = `
{
  "constraints": [
    {
      "constraintId": "domain-no-imports-from-app-or-infra",
      "detectionSteps": [
        "Enumerate every file under /domain/ excluding ignored paths.",
        "Parse and classify each import specifier relative to the current file.",
        "Record an initial violation whenever the resolved layer is app or infra.",
      ],
      "enforcementOrder": 1,
      "fixStrategy": "Determine whether the import is orchestration or infrastructural.",
      "objective": "Domain layer MUST NOT import code from app or infra layers.",
      "passCriteria": "violations list empty after final pass.; Each initial violation referenced in fixes_applied.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line",
        "specifier",
        "resolved_layer",
      ],
      "selfVerificationChecklist": [
        "No domain file imports from '/app/' or '/infra/'.",
        "Newly added files continue to satisfy single-responsibility and max-file-lines.",
      ],
    },
    {
      "constraintId": "app-no-imports-from-infra",
      "detectionSteps": [
        "Collect every /app/ file except ignored paths.",
        "Parse import statements and classify their resolved layer.",
        "Emit violations for any import mapped to infra.",
      ],
      "enforcementOrder": 2,
      "fixStrategy": "Identify the concrete capability pulled from infra (database access, queue, etc.).",
      "objective": "Application layer MUST NOT depend directly on infrastructure implementations.",
      "passCriteria": "No app file imports infra modules.; fixes_applied references each original violation.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line",
        "specifier",
        "resolved_layer",
      ],
      "selfVerificationChecklist": [
        "App layer depends only on domain + external packages.",
        "Any required infra capability exposed through a facade or service interface.",
      ],
    },
    {
      "constraintId": "domain-no-side-effects",
      "detectionSteps": [
        "Enumerate domain files.",
        "Scan call expressions for known side-effect APIs (fs, process, console, timers, randomness).",
        "Detect mutable globals or clock access performed without injection.",
      ],
      "enforcementOrder": 3,
      "fixStrategy": "Classify violation as IO, logging, timing, randomness, or global mutation.",
      "objective": "Domain logic MUST remain deterministic and side-effect free.",
      "passCriteria": "violations list empty.; Domain files only depend on injected collaborators for side effects.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line",
        "expression",
        "reason",
      ],
      "selfVerificationChecklist": [
        "Each side-effectful concern lives in app or infra.",
        "Domain tests run deterministically without stubs that hit IO.",
      ],
    },
    {
      "constraintId": "max-file-lines",
      "detectionSteps": [
        "List all .ts/.tsx files under src excluding ignored directories.",
        "Count logical (non-comment, non-blank) lines for each file.",
        "Record files whose counts exceed 300 lines.",
      ],
      "enforcementOrder": 4,
      "fixStrategy": "Identify cohesive responsibilities within the oversized file.",
      "objective": "All implementation files MUST remain at or below 300 logical lines.",
      "passCriteria": "No files exceed 300 logical lines.; Each extracted module honors single-responsibility and export limits.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "line_start",
        "line_end",
        "logical_line_count",
      ],
      "selfVerificationChecklist": [
        "Each new file reports <= 300 logical lines.",
        "Unit tests reference new modules instead of the old monolith.",
      ],
    },
    {
      "constraintId": "single-responsibility",
      "detectionSteps": [
        "Enumerate .ts/.tsx files under src.",
        "Parse every export (functions, classes, consts, types) plus inferred category.",
        "Flag files exceeding three exports or mixing multiple responsibility categories.",
      ],
      "enforcementOrder": 5,
      "fixStrategy": "Identify the core responsibility represented by the file.",
      "objective": "Each implementation file MUST focus on a single responsibility with minimal exports.",
      "passCriteria": "export_count <= 3 for every file.; All exports in a file share the same responsibility_category.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "export_count",
        "primary_category",
        "extra_exports",
      ],
      "selfVerificationChecklist": [
        "Each new file name reflects its responsibility.",
        "Barrel files do not reintroduce excessive exports via wildcard spreads.",
      ],
    },
    {
      "constraintId": "excessive-nesting",
      "detectionSteps": [
        "Enumerate .ts/.tsx files.",
        "Parse each function/method body and compute maximum block depth.",
        "Report functions whose max_nesting exceeds 3.",
      ],
      "enforcementOrder": 6,
      "fixStrategy": "Identify decision points contributing to depth.",
      "objective": "Control flow nesting depth MUST NOT exceed 3 levels in any function.",
      "passCriteria": "max_nesting <= 3 for all functions.; Extracted helpers remain within single-responsibility bounds.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "function_name",
        "max_nesting",
        "line_start",
        "line_end",
      ],
      "selfVerificationChecklist": [
        "Guard clauses cover invalid states early.",
        "Complex workflows are documented with sequence diagrams or ADRs when needed.",
      ],
    },
    {
      "constraintId": "file-naming",
      "detectionSteps": [
        "List all files under src excluding ignored directories.",
        "Infer expected naming pattern (kebab vs Pascal) per file type.",
        "Flag file names that do not match the expected pattern.",
      ],
      "enforcementOrder": 7,
      "fixStrategy": "Determine the correct case rule for the file (kebab or Pascal).",
      "objective": "File names MUST follow deterministic casing rules by layer and artifact type.",
      "passCriteria": "All \`.ts\` files use kebab-case (plus optional \`.spec\`/\`.test\` suffix).; All \`.tsx\` component files use PascalCase.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "file_path",
        "actual_name",
        "expected_pattern",
        "reason",
      ],
      "selfVerificationChecklist": [
        "\`git status --short\` shows the rename operation on case-sensitive systems.",
        "Storybook or routing metadata updated to reflect new casing when needed.",
      ],
    },
    {
      "constraintId": "folder-naming",
      "detectionSteps": [
        "Enumerate every directory under src (excluding ignored paths).",
        "Validate each basename against kebab-case unless reserved root.",
        "Detect case-collision groups that differ only by casing.",
      ],
      "enforcementOrder": 8,
      "fixStrategy": "Rename offending folders to kebab-case (lowercase words separated by dashes).",
      "objective": "Directory names MUST follow deterministic kebab-case conventions to avoid ambiguity on case-sensitive systems.",
      "passCriteria": "All non-reserved directories are kebab-case.; No case-collision duplicates remain.; revalidated_zero equals true.",
      "reportFields": [
        "constraint_id",
        "folder_path",
        "actual_name",
        "expected_pattern",
      ],
      "selfVerificationChecklist": [
        "\`git status\` shows directory renames tracked correctly.",
        "Path aliases (tsconfig paths, webpack) reflect the new casing.",
      ],
    },
    {
      "constraintId": "mvc-layer-separation",
      "detectionSteps": [
        "Ensure controller, model, and view layers each contain at least one implementation file; record missing-layer violations before deeper analysis.",
        "Enumerate controller files, parse imports, and flag data-access-api usage or direct imports from '/views/'.",
        "Enumerate model files and flag imports referencing controllers or views.",
        "Enumerate view files and flag occurrences of data-access-api usage or business logic keywords (calculations, validation, repository calls).",
        "Aggregate every breach into violations_mvc with precise line numbers and context details.",
      ],
      "enforcementOrder": 9,
      "fixStrategy": "Scaffold missing MVC layers so controllers, models, and views each have concrete implementations.",
      "objective": "Ensure Model-View-Controller responsibilities remain isolated so controllers orchestrate requests, models encapsulate domain logic, and views render presentation only. React/Next projects that follow the hook-based architecture from ARCHITECTURE.md should keep this constraint disabled; enable it only when building a traditional MVC UI stack.",
      "passCriteria": "violations_mvc array is empty after remediation; Controllers, models, and views layers each contain at least one implementation file; Controllers contain orchestration only (no data-access-api usage remains); Views contain presentation logic only; revalidated_zero equals true",
      "reportFields": [
        "constraint_id",
        "layer",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Controllers delegate domain logic to models or services and select views via contracts",
        "Models expose domain methods consumed by controllers without referencing views",
        "Views render data passed by controllers without side effects or persistence",
      ],
    },
    {
      "constraintId": "mvp-presenter-boundaries",
      "detectionSteps": [
        "Ensure presenter, view, and model layers exist and contain implementations; emit missing-layer violations when absent.",
        "List presenter files and inspect constructor dependencies for concrete view classes; flag when no view-interface or inversion present.",
        "Inspect presenter files to ensure they export interfaces or types for views to implement.",
        "Scan view files for imports from models or presenters and for stateful-logic occurrences.",
        "Inspect model files to confirm they do not import presenters or views.",
      ],
      "enforcementOrder": 10,
      "fixStrategy": "Create or restore presenter, view, and model layers with concrete implementations and shared contracts.",
      "objective": "Maintain clear separation between Model-View-Presenter responsibilities so presenters coordinate state, views handle rendering, and models encapsulate data logic without cross-layer leakage. React+Next teams generally rely on feature hooks instead of presenters, so leave this constraint disabled unless you are intentionally adopting MVP in another UI framework.",
      "passCriteria": "violations_mvp array empty; Presenter, view, and model layers contain at least one implementation file each; All presenter dependencies on views go through interfaces or injected callbacks; Every presenter exposes a view-interface contract implemented by the view layer; Views contain only rendering logic and event wiring; revalidated_zero equals true",
      "reportFields": [
        "constraint_id",
        "layer",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Presenters own state management, orchestrating models and pushing updates to views via interfaces",
        "Views implement interfaces, trigger callbacks, and avoid domain decisions",
        "Models stay independent from presenters and views",
      ],
    },
    {
      "constraintId": "mvvm-binding-integrity",
      "detectionSteps": [
        "Ensure viewmodel, view, and model layers each contain implementation files; record missing-layer violations when absent.",
        "Parse view model files to confirm imports exclude views, UI-thread-api, or DOM manipulation libraries.",
        "Inspect views to confirm bindings to viewmodels, flagging missing bindings, direct state mutation, or business logic/persistence.",
        "Inspect model files to ensure they do not import viewmodels or views.",
      ],
      "enforcementOrder": 11,
      "fixStrategy": "Create or restore viewmodel, view, and model layers with concrete MVVM implementations and bindings.",
      "objective": "Guarantee Model-View-ViewModel boundaries by enforcing one-way dependencies, keeping view models free of view references, and ensuring views bind without business logic. The React/TanStack Query stack does not rely on MVVM, so this constraint ships disabled and should only be enabled for teams building MVVM-based clients (e.g., mobile or desktop shells).",
      "passCriteria": "violations_mvvm array empty; Viewmodel, view, and model layers each contain at least one implementation file; Every view binds to a viewmodel through declarative bindings or exposed commands; View models depend only on models/shared utilities, never on views or UI APIs; Views bind declaratively without business logic or direct state mutation; revalidated_zero equals true",
      "reportFields": [
        "constraint_id",
        "layer",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "View models expose state and commands independent of UI frameworks",
        "Views bind to viewmodel state and trigger commands without domain logic",
        "Models remain UI-agnostic and interact only with domain concerns",
      ],
    },
    {
      "constraintId": "clean-layer-direction",
      "detectionSteps": [
        "Determine each source file's layer classification using DEFINITIONS and ensure every layer has at least one implementation to confirm coverage.",
        "Build an import graph across all classified files and compute layer_dependencies with resolved source/target layers.",
        "Flag any dependency whose source_layer ranks lower (later) than target_layer or violates allowed adapters list.",
        "Run cycle detection across the import graph limited to classified nodes and record any strongly connected components larger than one.",
        "Summarize violations with precise file_path, line, specifier, source_layer, and target_layer details.",
      ],
      "enforcementOrder": 12,
      "fixStrategy": "Break any detected cycles by extracting shared abstractions or introducing ports so that dependency arrows flow one direction.",
      "objective": "Guarantee that dependencies always flow from UI ➜ App ➜ Domain ➜ Infra and that shared utilities never skip layers or re-import lower abstractions.",
      "passCriteria": "No layer_dependencies entries violate the approved direction table; cycles_detected array is empty; ui files import only presenters/view-models or shared utilities; domain files import only domain peers or shared utilities",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "source_layer",
        "target_layer",
        "file_path",
        "line",
        "specifier",
      ],
      "selfVerificationChecklist": [
        "Dependency graph is acyclic and respects ui ➜ app ➜ domain ➜ infra order",
        "Shared utilities remain side-effect free and layer-agnostic",
        "Infra modules expose ports/adapters instead of being imported upstream",
      ],
    },
    {
      "constraintId": "domain-purity",
      "detectionSteps": [
        "Enumerate all domain files and parse their import statements, mapping each specifier to a resolved layer.",
        "Flag imports that reference app/ui/infra directories or any package from the disallowed SDK list (framework, ORM, HTTP clients).",
        "Scan AST bodies for calls to side-effect-api or usage of impure tokens (Date.now, Math.random, process.env, console.*).",
        "Detect exported instances or module-level stateful caches and record impure_patterns.",
        "Summarize violations per file with reason codes.",
      ],
      "enforcementOrder": 13,
      "fixStrategy": "Remove forbidden imports by moving IO and framework access into app/infra layers or injecting them through port interfaces.",
      "objective": "Keep the domain layer deterministic by prohibiting IO, framework bindings, or temporal coupling inside \`src/domain/**\`.",
      "passCriteria": "No forbidden domain_imports referencing non-domain layers; side_effect_calls array empty; impure_patterns array empty; All domain exports remain pure and deterministic",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Domain modules accept data and collaborators via parameters",
        "No console, clock, randomness, or IO APIs exist in src/domain/**",
        "Shared utilities imported by domain are themselves side-effect free",
      ],
    },
    {
      "constraintId": "ports-and-adapters-integrity",
      "detectionSteps": [
        "Catalog every export under \`src/domain/ports\` and ensure export_kind is interface/type; record violations for classes/functions.",
        "Parse app modules to resolve imports; mark any specifier pointing to \`src/infra/adapters\` as violation \`app-imports-adapter\`.",
        "Inspect adapter classes to confirm they declare \`implements <Port>\` or satisfy the port type via assignment.",
        "Compute orphan_ports by finding ports with zero adapters referencing them; compute unbound_adapters when adapters implement nothing.",
        "Produce violation entries for each rule breach.",
      ],
      "enforcementOrder": 14,
      "fixStrategy": "Convert concrete exports under \`src/domain/ports\` into interface/type definitions and move implementations elsewhere.",
      "objective": "Ensure app services depend on domain ports, ports stay interface-only, and infra adapters implement those ports without leaking concrete dependencies upstream.",
      "passCriteria": "No app modules import adapter paths directly; Every port export is interface/type-only; Every adapter implements at least one port and all ports referenced by app modules have adapters; orphan_ports and unbound_adapters arrays empty",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Ports directory contains contracts only, with no side-effectful code",
        "App layer interacts strictly with ports; adapters are injected at composition roots",
        "Infra adapters advertise the ports they fulfill via explicit implements clauses",
      ],
    },
    {
      "constraintId": "central-config-entrypoint",
      "detectionSteps": [
        "Scan entire src tree for \`process.env\`, \`dotenv.config\`, or known secret SDK calls outside the canonical entrypoint and record env_reads entries.",
        "Parse the entrypoint file to ensure it exports typed getters; warn if it re-exports raw env vars without validation.",
        "Identify modules that declare configuration constants (filenames matching \`*config*.ts\`) and confirm they import from the entrypoint; otherwise record them as alternate_config_modules.",
        "Summarize violations with actionable context.",
      ],
      "enforcementOrder": 15,
      "fixStrategy": "Move all env reads into \`src/infra/config/index.ts\`, wrapping them with validation and sane defaults.",
      "objective": "Route all runtime configuration (environment variables, secrets, flags) through \`src/infra/config/index.ts\` so no module reads \`process.env\` or secret stores directly.",
      "passCriteria": "env_reads array empty for all files except the entrypoint; No alternate config modules remain outside the canonical path; Entry point exports at least one getter/function with validation",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Only the canonical entrypoint reads external configuration sources",
        "All other modules import typed helpers or receive config via DI",
        "Entry point validates and documents every configuration key",
      ],
    },
    {
      "constraintId": "structural-naming-consistency",
      "detectionSteps": [
        "Enumerate immediate subdirectories of each layer and derive slugs; validate they are kebab-case.",
        "For each feature root, ensure an entry-file exists whose basename starts with the slug.",
        "Build the canonical-slug-map by grouping equivalent slugs; flag collisions where layers disagree on naming.",
        "Detect duplicates where only pluralization or casing differs (billing vs Billing vs billings).",
      ],
      "enforcementOrder": 16,
      "fixStrategy": "Rename offending folders to kebab-case slugs and update import paths across the repo.",
      "objective": "Keep feature folders and entry files aligned across layers so a feature has the same slug in \`ui\`, \`app\`, \`domain\`, and \`infra\`, preventing drift caused by ad-hoc pluralization or casing.",
      "passCriteria": "All feature root folders are kebab-case; Each feature root exposes an entry file that begins with the slug; slug_collisions array empty",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "layer",
        "folder_path",
        "details",
      ],
      "selfVerificationChecklist": [
        "Feature folder names match across layers and follow kebab-case",
        "Entry files expose the same slugged prefix and appear in import statements",
        "No duplicate routing or module paths remain",
      ],
    },
    {
      "constraintId": "module-complexity-guardrails",
      "detectionSteps": [
        "Iterate over all source modules within scope, skipping tests and generated directories.",
        "Compute module_metrics (logical lines, export count, max cyclomatic complexity, max nesting depth).",
        "Compare each metric against thresholds; record violations with specifics (function name, block range).",
        "Flag mixed responsibility files by detecting both JSX/TSX components and non-view logic or style strings.",
      ],
      "enforcementOrder": 17,
      "fixStrategy": "Split oversized modules into focused files aligned to single responsibility (e.g., extract presenters, hooks, utilities).",
      "objective": "Prevent runaway modules by enforcing upper bounds for logical lines, exported symbols, cyclomatic complexity, and nested branches beyond what \`max-file-lines\` and \`excessive-nesting\` already cover.",
      "passCriteria": "No file exceeds lines, exports, complexity, or nesting thresholds; module_metrics recorded for every analyzed file; Mixed responsibility flag absent",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line_start",
        "line_end",
        "observed_value",
        "threshold",
        "details",
      ],
      "selfVerificationChecklist": [
        "Each module serves a singular purpose with manageable size",
        "Cyclomatic complexity reports show maximum <= 12",
        "Export lists contain only the minimal public surface needed",
      ],
    },
    {
      "constraintId": "ui-isolation",
      "detectionSteps": [
        "Parse imports within feature_component files and classify resolved_layer; flag anything referencing forbidden_layer.",
        "Analyze AST bodies for calls to shared_client_module, fetch, axios.*, graphqlClient.*, repository.*, or TanStack Query primitives invoked directly by the component and record service_calls.",
        "Count conditional nodes per component render function; flag components exceeding decision_points > 3.",
        "Report each breach with file, line, and remediation hint.",
      ],
      "enforcementOrder": 18,
      "fixStrategy": "Extract business logic out of UI components into feature hooks/services under \`apps/web/src/features/*/{hooks,services}\` and inject results via props.",
      "objective": "Keep Next.js/React UI components focused on rendering by forcing all IO and orchestration through feature hooks/services instead of importing backend modules or HTTP clients directly.",
      "passCriteria": "component_imports never resolve to forbidden_layer targets; service_calls array empty within feature_component files; branching_complexity entries <= 3 decision points per component",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "UI components receive all data via hooks/props without importing shared_client_module",
        "No HTTP or persistence logic resides in \`apps/web/src/features/*/components\`",
        "Render functions remain declarative with minimal branching",
      ],
    },
    {
      "constraintId": "api-boundary-hygiene",
      "detectionSteps": [
        "Parse controller imports; flag any that resolve to \`src/infra/persistence\` or raw ORM models.",
        "Analyze return statements to determine if a domain entity/class is serialized directly.",
        "Inspect each controller for mapper usage by searching for functions named \`toDomain\`, \`fromDomain\`, or modules imported from \`mappers\` directories; flag missing cases.",
        "Ensure controllers call application services located under \`src/app/services\` instead of domain modules directly.",
      ],
      "enforcementOrder": 19,
      "fixStrategy": "Route controller logic through application services that encapsulate domain interactions.",
      "objective": "Keep HTTP/controllers transport concerns isolated by ensuring DTOs never leak domain entities, persistence models stay hidden, and every request flows through application services plus dedicated mappers.",
      "passCriteria": "No controller imports infra or domain implementations directly; domain_returns array empty; Every controller references a mapper module; Controllers invoke application services exclusively",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Controller responses are DTOs documented in API specs",
        "Application services encapsulate domain interactions",
        "Mapper modules own all serialization/deserialization logic",
      ],
    },
    {
      "constraintId": "observability-discipline",
      "detectionSteps": [
        "Scan for \`console.*\`, \`logger = new\`, \`metricsClient = new\`, or imports from known telemetry SDKs; classify whether approved adapters are used.",
        "Inspect argument lists to ensure a \`context\` object containing \`correlationId\` (and optionally user/session) is passed.",
        "Detect catch blocks that log errors but do not rethrow or return failure signals.",
        "Record violations for each offense with actionable details.",
      ],
      "enforcementOrder": 20,
      "fixStrategy": "Replace console/third-party logger usage with the approved telemetry adapters and ensure they are injected where necessary.",
      "objective": "Guarantee all logs and metrics route through shared telemetry adapters (e.g., \`src/infra/telemetry/logger.ts\`, \`src/infra/telemetry/metrics.ts\`) so context, correlation IDs, and formatting remain consistent.",
      "passCriteria": "All telemetry_calls originate from approved adapters; has_context flag true for every recorded call; direct_logger_instantiations and suppressed_errors arrays empty",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "Telemetry adapters are the only path to emit logs/metrics",
        "Context propagation verified via automated tests",
        "Error handling surfaces failures after logging",
      ],
    },
    {
      "constraintId": "test-coverage-contracts",
      "detectionSteps": [
        "Enumerate production modules per layer and derive expected_test_path using mirrored directories plus \`.test.ts\` suffix.",
        "Check filesystem for presence; record coverage_matrix entries with test_exists flag.",
        "Parse tests to classify coverage_kind (unit/integration/etc.) based on location and helper usage.",
        "Inspect test imports to ensure domain tests do not import infra adapters and vice versa.",
        "For UI tests, confirm there is at least one user interaction plus assertion.",
      ],
      "enforcementOrder": 21,
      "fixStrategy": "Create the missing mirrored test files with the appropriate isolation level per layer.",
      "objective": "Tie architecture layers to matching test suites so every critical module has the correct test counterpart (unit for domain, integration for app/infra, interaction for UI).",
      "passCriteria": "Every production module has a test counterpart; improper_test_imports array empty; UI tests record both interactions and assertions",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "details",
      ],
      "selfVerificationChecklist": [
        "coverage_matrix shows 100% mirrored files with appropriate coverage_kind",
        "Tests respect isolation boundaries (domain/unit, app/integration, infra/adapter, ui/interaction)",
        "UI suites assert user-facing outcomes rather than internal state only",
      ],
    },
    {
      "constraintId": "fastify-http-server",
      "detectionSteps": [
        "Enumerate controller_files under \`apps/api/src/features/**/http.controller.ts\`.",
        "Parse import specifiers for each controller_file.",
        "Mark violations when fastify_import missing or disallowed_http_framework present.",
        "Ensure bootstrap_files only instantiate Fastify and register plugins/routes via Fastify APIs.",
      ],
      "enforcementOrder": 22,
      "fixStrategy": "Replace foreign HTTP imports with Fastify primitives (\`FastifyInstance\`, \`FastifyRequest\`, \`FastifyReply\`).",
      "objective": "Guarantee that \`apps/api\` exposes HTTP endpoints exclusively through Fastify so routing, hooks, and plugins stay centralized in the documented server bootstrap.",
      "passCriteria": "All controller_files import from \`fastify\`.; No disallowed_http_framework imports remain.; Exactly one bootstrap registers every HTTP route through Fastify APIs.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "specifier",
      ],
      "selfVerificationChecklist": [
        "\`npm run dev\` for \`apps/api\` shows Fastify banner.",
        "Controllers expose only Fastify handler signatures.",
      ],
    },
    {
      "constraintId": "zod-contracts",
      "detectionSteps": [
        "Enumerate boundary_files under scopes defined above.",
        "Parse import specifiers to confirm \`@shared-types/\` paths or relative imports from \`packages/shared-types\`.",
        "Flag files importing \`joi\`, \`yup\`, \`ajv\`, or raw regex validation.",
        "Detect inline \`z.object\` declarations within apps layers and confirm they reference only local concerns.",
      ],
      "enforcementOrder": 23,
      "fixStrategy": "Move Zod definitions for shared DTOs into \`packages/shared-types\`.",
      "objective": "Ensure HTTP handlers, RPC endpoints, and form adapters validate all cross-boundary payloads with Zod schemas sourced from \`packages/shared-types\`.",
      "passCriteria": "Every boundary_handler imports at least one shared_schema.; No alternative validation frameworks exist in boundary scopes.; Shared schemas remain single source of truth for payloads.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "specifier",
        "referenced_schema",
      ],
      "selfVerificationChecklist": [
        "\`packages/shared-types\` exports compile without circular dependencies.",
        "API handlers and forms both call \`schema.safeParse\` on incoming data.",
      ],
    },
    {
      "constraintId": "prisma-data-access",
      "detectionSteps": [
        "Traverse \`apps/api/src/features/**/infra/**/*\`.",
        "Capture import_specifiers for each file.",
        "Flag adapters lacking \`@prisma/client\` imports.",
        "Scan domain/usecase directories for prisma_client imports and flag.",
        "Detect direct_sql usage via regex for \`from "pg"\` or \`\`sql\`SELECT\`\`.",
      ],
      "enforcementOrder": 24,
      "fixStrategy": "Centralize PrismaClient creation in \`apps/api/src/infra/db/prismaClient.ts\`.",
      "objective": "Mandate that persistence logic under \`apps/api\` uses Prisma clients wired through feature-specific adapters so repositories stay type-safe and composable.",
      "passCriteria": "Only infra adapters import \`@prisma/client\`.; No raw SQL libraries exist under \`apps/api/src\`.; PrismaClient instantiated once and shared via adapters.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "layer",
      ],
      "selfVerificationChecklist": [
        "Unit tests mock repository ports rather than Prisma directly.",
        "\`npm run prisma:generate\` completes without schema drift.",
      ],
    },
    {
      "constraintId": "nextjs-app-structure",
      "detectionSteps": [
        "Enumerate routing_files under \`app/\` and \`pages/\`.",
        "Confirm each routing_leaf exports minimal logic and imports from \`src/features/<slug>\` or \`src/lib\`.",
        "Flag routing files that declare hooks/services locally or import from random directories.",
        "Detect feature directories created under routing trees instead of \`src/features\`.",
      ],
      "enforcementOrder": 25,
      "fixStrategy": "Move reusable hooks/services/components into \`apps/web/src/features/<feature>\` folders.",
      "objective": "Align \`apps/web\` with the documented Next.js layout so routing files stay thin, feature logic lives under \`src/features\`, and shared libs (\`apiClient\`, \`queryClient\`) remain the only IO entrypoints.",
      "passCriteria": "Route trees only wire layouts/metadata while delegating logic to feature modules.; Feature modules live exclusively under \`apps/web/src/features\`.; Shared libs (\`apiClient\`, \`queryClient\`) stay under \`apps/web/src/lib\`.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "details",
      ],
      "selfVerificationChecklist": [
        "\`apps/web\` build succeeds with consistent module aliasing.",
        "Feature entry points expose UI + hooks but routing code remains minimal.",
      ],
    },
    {
      "constraintId": "react-ui-only",
      "detectionSteps": [
        "Enumerate component_files under configured folders.",
        "Parse import_specifiers; flag any reference to io_import or domain_module.",
        "Scan AST for \`fetch\`, \`axios\`, \`apiClient\`, or \`new QueryClient\` usage.",
      ],
      "enforcementOrder": 26,
      "fixStrategy": "Extract IO logic into feature hooks under \`apps/web/src/features/<feature>/hooks\`.",
      "objective": "Keep React components focused on presentation by forbidding direct IO, domain orchestration, or backend imports inside \`apps/web\` component directories.",
      "passCriteria": "Components import only UI dependencies plus hooks/props.; No HTTP or persistence libraries appear inside component directories.; Async behavior mediated through hooks/services.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "specifier",
      ],
      "selfVerificationChecklist": [
        "Storybook or unit tests mount components with mocked props instead of network calls.",
        "\`apps/web/src/features/*/hooks\` expose typed APIs consumed by UI.",
      ],
    },
    {
      "constraintId": "tanstack-query-async",
      "detectionSteps": [
        "Identify \`.ts\`/\`.tsx\` files importing \`fetch\`, \`axios\`, or \`apiClient\`.",
        "Determine whether file already calls \`useQuery\`/\`useMutation\`.",
        "Flag files performing raw_fetch_call within React component bodies or custom hooks without wrapping TanStack Query.",
        "Detect new \`QueryClient()\` expressions outside \`query_client_module\`.",
      ],
      "enforcementOrder": 27,
      "fixStrategy": "Move HTTP calls into query_hook factories using \`useQuery\`/\`useMutation\`.",
      "objective": "Enforce that asynchronous HTTP interactions inside \`apps/web\` flow through the shared TanStack Query client so caching, retries, and suspense behavior stay centralized.",
      "passCriteria": "All async UI operations use TanStack Query hooks.; Only one query_client_module instantiates QueryClient.; Hooks expose typed data/selectors derived from query results.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "specifier",
      ],
      "selfVerificationChecklist": [
        "\`_app.tsx\` or equivalent wraps the tree with \`QueryClientProvider\`.",
        "Feature hooks expose \`queryKey\` constants reused across consumers.",
      ],
    },
    {
      "constraintId": "axios-client-only",
      "detectionSteps": [
        "Traverse \`apps/web/src/**/*.ts*\`.",
        "Flag direct_axios_import occurrences outside shared_client_module.",
        "Detect modules exporting Axios instances via \`axios.create\` outside shared_client_module.",
        "Ensure shared_client_module is the only file importing raw Axios.",
      ],
      "enforcementOrder": 28,
      "fixStrategy": "Move Axios configuration (base URL, interceptors, auth headers) into shared_client_module.",
      "objective": "Force every HTTP request on the frontend to flow through the shared Axios wrapper \`apps/web/src/lib/apiClient.ts\` so headers, interceptors, and telemetry stay consistent.",
      "passCriteria": "Exactly one file imports \`axios\`.; All other modules call shared_client_module exports.; Interceptors execute globally (auth, telemetry, error logging).",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "line",
        "specifier",
      ],
      "selfVerificationChecklist": [
        "Integration tests stub shared_client_module instead of raw Axios.",
        "Shared client exports typed helpers (get/post/mutate) consumed across features.",
      ],
    },
    {
      "constraintId": "shared-types-zod-source-of-truth",
      "detectionSteps": [
        "Enumerate Zod schemas declared in \`apps/api\` and \`apps/web\`.",
        "Match their names/structures against shared_types_module exports.",
        "Flag duplicates where same name exists outside packages/shared-types.",
        "Detect boundary files (controllers, route handlers, feature hooks) that access DTOs without importing shared modules.",
      ],
      "enforcementOrder": 29,
      "fixStrategy": "Move contract_schema definitions into \`packages/shared-types/src/<feature>/<schema>.ts\`.",
      "objective": "Make \`packages/shared-types\` the canonical location for cross-boundary Zod schemas so both \`apps/api\` and \`apps/web\` consume identical DTOs, enums, and validators.",
      "passCriteria": "Every boundary handler references contract_schema from shared_types_module.; No duplicate_schema definitions remain.; Shared package builds with zero circular imports.",
      "reportFields": [
        "constraint_id",
        "violation_type",
        "file_path",
        "schema",
        "line",
      ],
      "selfVerificationChecklist": [
        "\`packages/shared-types\` tests cover the moved schemas.",
        "API responses documented in README reference shared schema names.",
      ],
    },
  ],
  "ignoredPaths": [
    "node_modules",
    "dist",
    "build",
    ".git",
  ],
  "mode": "batch",
  "recommendedOrder": [
    "domain-no-imports-from-app-or-infra",
    "app-no-imports-from-infra",
    "domain-no-side-effects",
    "max-file-lines",
    "single-responsibility",
    "excessive-nesting",
    "file-naming",
    "folder-naming",
    "mvc-layer-separation",
    "mvp-presenter-boundaries",
    "mvvm-binding-integrity",
    "clean-layer-direction",
    "domain-purity",
    "ports-and-adapters-integrity",
    "central-config-entrypoint",
    "structural-naming-consistency",
    "module-complexity-guardrails",
    "ui-isolation",
    "api-boundary-hygiene",
    "observability-discipline",
    "test-coverage-contracts",
    "fastify-http-server",
    "zod-contracts",
    "prisma-data-access",
    "nextjs-app-structure",
    "react-ui-only",
    "tanstack-query-async",
    "axios-client-only",
    "shared-types-zod-source-of-truth",
  ],
  "reportTemplate": {
    "agentExecutionSignature": null,
    "analysisPerformed": false,
    "completionTimestamp": null,
    "constraintBlocksReceived": 29,
    "enumeratedFilesCount": 0,
    "executionState": "unvalidated",
    "fixesApplied": [],
    "initialViolationCount": 0,
    "postFixStatus": {
      "remainingViolations": 0,
      "revalidated": false,
    },
    "remainingViolationCount": 0,
    "reportKind": "cda_validation_result",
    "revalidationAttemptsUsed": 0,
    "runId": "snapshot-run",
    "selfAudit": {
      "allConstraintsPresent": false,
      "allRequiredFieldsPopulated": false,
      "revalidationAttemptsDocumented": false,
      "schemaConformance": false,
    },
    "status": null,
    "successConditions": {
      "allConstraintsEvaluated": false,
      "noRemainingViolations": false,
    },
    "summary": {
      "analyzedFiles": 0,
      "constraintsEvaluated": 29,
      "totalViolations": 0,
    },
    "violations": [],
  },
  "runId": "snapshot-run",
}
`;

exports[`instructionEmitter > creates single package snapshot 1`] = `
{
  "constraint": {
    "constraintId": "domain-no-imports-from-app-or-infra",
    "detectionSteps": [
      "Enumerate every file under /domain/ excluding ignored paths.",
      "Parse and classify each import specifier relative to the current file.",
      "Record an initial violation whenever the resolved layer is app or infra.",
    ],
    "enforcementOrder": 1,
    "fixStrategy": "Determine whether the import is orchestration or infrastructural.",
    "objective": "Domain layer MUST NOT import code from app or infra layers.",
    "passCriteria": "violations list empty after final pass.; Each initial violation referenced in fixes_applied.; revalidated_zero equals true.",
    "reportFields": [
      "constraint_id",
      "file_path",
      "line",
      "specifier",
      "resolved_layer",
    ],
    "selfVerificationChecklist": [
      "No domain file imports from '/app/' or '/infra/'.",
      "Newly added files continue to satisfy single-responsibility and max-file-lines.",
    ],
  },
  "mode": "single",
  "reportTemplate": {
    "agentExecutionSignature": null,
    "analysisPerformed": false,
    "completionTimestamp": null,
    "constraintBlocksReceived": 1,
    "constraintId": "domain-no-imports-from-app-or-infra",
    "enumeratedFilesCount": 0,
    "executionState": "unvalidated",
    "fixesApplied": [],
    "initialViolationCount": 0,
    "postFixStatus": {
      "remainingViolations": 0,
      "revalidated": false,
    },
    "remainingViolationCount": 0,
    "reportKind": "cda_single_constraint_validation_result",
    "revalidationAttemptsUsed": 0,
    "runId": "snapshot-run",
    "selfAudit": {
      "allConstraintsPresent": false,
      "allRequiredFieldsPopulated": false,
      "revalidationAttemptsDocumented": false,
      "schemaConformance": false,
    },
    "status": null,
    "successConditions": {
      "allConstraintsEvaluated": false,
      "noRemainingViolations": false,
    },
    "violations": [],
  },
  "runId": "snapshot-run",
}
`;
