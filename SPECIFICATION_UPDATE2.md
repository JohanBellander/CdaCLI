# Specification Update 2 (Restructured): Agent-Agnostic Verification Command (Copilot CLI MVP)

## 1. Context
The CDA CLI emits instruction-only validation packages (`cda validate`) describing HOW an agent should evaluate architectural constraints; it never performs code scanning itself. Teams need a deterministic, agent-ready wrapper to hand these packages to an external AI CLI (initially GitHub Copilot CLI) so automated agents can execute detection and remediation loops. Design must remain vendor-neutral, expose stable sentinels for machine parsing, and preserve backward compatibility with existing instruction output.

## 2. Goals
1. Introduce `cda agent` to assemble an agent-ready verification prompt and optionally invoke an external AI CLI.
2. Support GitHub Copilot CLI first while keeping design agent-agnostic.
3. Use a lightweight root config (`cda.agents.json`) for invocation details.
4. Provide a safe `--dry-run` mode to inspect generated prompt and shell invocation before executing.
5. Preserve existing instruction formatting; do not parse AI output yet.
6. Allow single-constraint or batch mode reuse (mirrors `cda validate` options).

## 3. Non-Goals (MVP)
- No automatic interpretation or validation of the agent’s response.
- No multi-agent chaining.
- No network-aware rate limiting or retries.
- No trust scoring or Merkle proof integration.
- No JSON schema validation of agent output.

## 4. Terminology
- Instruction Package: Output of `cda validate` (batch or single).
- Verification Prompt: Wrapped instruction package + directives sent to AI CLI.
- Agent Config: JSON file describing how to call an external CLI tool.

## 5. User Stories
1. As a developer, I can run `cda agent --dry-run` to preview the prompt that would be sent to Copilot.
2. As a developer, I can run `cda agent` and stream Copilot’s response directly in the terminal.
3. As a team, we can add another agent (e.g., `ollama`) later without code changes by editing `cda.agents.json`.
4. As a cautious user, I can disable execution but still generate the prompt (`--no-exec`).
5. As a verifier, I can scope to a single constraint: `cda agent --constraint domain-no-side-effects`.

## 6. Command Syntax & UX (MVP)
```
cda agent [--constraint <id> | --sequential] [--agent <name>] [--dry-run] [--no-exec] [--output <path>]
          [--legacy-format]
```
Options:
- `--agent <name>`: Select an agent defined in config. Defaults to config `default` or `copilot` if not specified.
- `--dry-run`: Do NOT execute; print resolved prompt + shell command.
- `--no-exec`: Alias of `--dry-run` but omits command; prints only prompt body.
- `--output <path>`: Write generated prompt to file (independent of execution). Always overwrites.
- `--constraint <id>`: Use single-constraint instruction package.
- `--sequential`: Shorthand for first constraint in recommended order (mirrors validate behavior).
- `--legacy-format`: Use legacy instruction formatting for models with token constraints.

Exit Codes:
- `0`: Command succeeded (regardless of external agent response content).
- Non-zero: Internal CDA error (bad config, unknown agent, missing constraint, external spawn failure).

## 7. Agent Config File (`cda.agents.json`)
Location: Project root (future: search `.cda/agents.json` fallback).
Minimal MVP Example (auto-generated by `cda init` unless `--no-agents`):
```json
{
  "default": "copilot",
  "agents": {
    "copilot": {
      "command": "copilot",
      "args": ["--model", "gpt-5", "--allow-all-tools"],
      "mode": "arg",
      "prompt_arg_flag": "-p",
      "prompt_file_arg": "--prompt-file",
      "prompt_preamble": "You are a verification agent. Execute CDA architectural constraint detection steps strictly.",
      "postscript": "Return ONLY the populated agent report format. Do not paraphrase instructions.",
      "max_length": 20000,
      "agent_model": "gpt-5"
    },
    "echo": {
      "command": "echo",
      "args": [],
      "mode": "stdin",
      "prompt_preamble": "Echo test agent. Do NOT treat output as evaluation.",
      "postscript": "End of echo agent."
    }
  }
}
```

## 7A. `CDA.md` Purpose & Content (Second-Person Imperative Guidance)
`CDA.md` generated by `cda init` is an authoritative instruction document written directly to **you** (the autonomous AI implementation and verification agent). It serves two tightly coupled purposes:
1. Implementation Guidance: It tells **you** exactly HOW you must apply architectural constraints during code changes (patterns you must follow, anti-patterns you must avoid, sequencing you must respect, guardrails you must not cross, and explicit non-interpretation disclaimers).
2. Validation & Agentic Flow Guidance: It tells **you** exactly HOW you must validate your implementation using the CDA verification loop (detection → violation cataloging → remediation attempts → re-detection → report finalization) and what actions you must take for each outcome class (SUCCESS, PARTIAL, INCOMPLETE).

### 7A.1 Core Principles Embedded (Second-Person Enforcement)
- Instruction-only: You MUST NOT assume current compliance; treat all compliance flags as placeholders until validation completes.
- Deterministic Steps: You MUST execute each listed detection step verbatim before proposing remediation.
- Separation of Phases: You MUST keep implementation edits separate from validation reporting; perform detection first, then remediation, then full re-detection.
- Non-Fabrication: You MUST NOT invent files, paths, or constraints not present in the instruction package.

### 7A.2 Expected Section Outline in `CDA.md` (Second-Person Wording)
1. Title & High-Level Purpose (explicit “You MUST …” phrasing).
2. Core Architectural Principles (each bullet begins with “You MUST” or “You MUST NOT”).
3. Constraint Summary Table (id, intent, criticality, remediation hint) addressed as “You MUST cover every listed constraint”.
4. Implementation Guidance Section:
  - For each constraint: “You MUST” allowed patterns; “You MUST NOT” disallowed patterns; minimal change strategy; rollback guidance.
5. Validation Workflow Section:
  - Ordered detection steps phrased as “You MUST perform …”.
  - Violation recording format: “You MUST record every violation with …”.
  - Remediation attempt protocol: “You MUST limit attempts …”.
  - Re-run verification rules: “You MUST re-execute ALL detection steps”.
6. Outcome Classification & Next Actions (SUCCESS / PARTIAL / INCOMPLETE) each starting with instructive second-person imperatives (e.g., “On PARTIAL you MUST open beads …”).
7. Reporting Template Snapshot (clearly states “Example only – You MUST populate after executing the loop”).
8. Safety & Scope Notes (all prohibitions addressed to “You”).
9. Token / Complexity Notice (“If token estimate exceeds limit, you MUST segment work …”).

### 7A.3 Relationship to `cda agent` (Second-Person)
`cda agent` wraps a dynamic instruction package for a specific run; `CDA.md` is your static architectural playbook. You MUST consult `CDA.md` to plan implementation, then use the runtime prompt from `cda agent` to execute the verification cycle. They are complementary; you MUST treat neither as a substitute for the other.

### 7A.4 Acceptance Hooks
Initialization is considered complete only if the generated `CDA.md` contains all mandatory second-person sections described in 7A.2 and 7A.7. Absence of any required heading or a failure to use “You” form in core imperative lines constitutes an initialization defect.

### 7A.5 Future Evolution (Non-MVP)
- Machine-readable YAML block for constraints (allow faster parsing).
- Embedded quick links to beads issues for open architectural refactors.
- Version header referencing `instruction_format_version` to tie static guidance to dynamic prompt structure.

### 7A.6 Rationale
Second-person imperative phrasing eliminates ambiguity: addressing **you** directly reduces the risk that autonomous parsing layers misinterpret passive constructions or third-person references.

---

### 7A.7 Imperative Instruction Blueprint (Second-Person Authoritative Content)
All wording MUST directly address **you**. Replace any instance of “the agent” with “you”. No passive voice for mandatory steps.

#### 7A.7.1 High-Level Purpose Block (Mandatory)
Title: `CDA Architectural Playbook (Authoritative Instructions To You)`
Intro paragraph MUST begin: “You are required to implement and validate code according to CDA architectural constraints. You MUST NOT assume current compliance; all example statuses are placeholders until you complete the full validation loop.”

#### 7A.7.2 Core Principles Block
Each bullet MUST start with “You MUST” or “You MUST NOT” followed by the principle keyword (Determinism, Purity Where Required, Layer Boundaries, Centralized Persistence, Consistent Logging, Canonical Configuration, Non-Fabrication, Separation of Phases, Minimality).

#### 7A.7.3 Constraint Summary Table
Columns: `id | intent | criticality | remediation_hint`. Table MUST enumerate every active constraint; absence of a constraint here implies it is out-of-scope for the agent.

#### 7A.7.4 Per-Constraint Implementation Section
For each constraint example template:
```
### <constraint-id>
You MUST perform:
1. <ordered detection preparation>
2. <mandatory implementation mandates>
You MUST NOT apply: <list of anti-patterns>
Rollback Strategy: You SHOULD revert only minimal adapter changes if tests fail.
```
Imperative verbs MUST retain capitalized modal verbs (MUST / MUST NOT / SHOULD / SHOULD NOT / DO NOT).

#### 7A.7.5 Command Usage Sequencing Section
Required headings: `Implementation Phase`, `Validation Phase`, `Batch Workflow`, `Safety Switches`.
Numbered steps MUST each begin “You MUST” or “You SHOULD” and explicitly instruct command usage. Safety Switches MUST state: “You MAY use `--no-exec`…”, “You SHOULD use `--dry-run` before executing…”.

#### 7A.7.6 Detection & Remediation Protocol (Second-Person)
Structure:
```
Detection Steps:
1. Establish file scope.
2. Static analysis pattern matching.
3. Record violations.

Remediation Attempts:
- Max attempts per violation: 2.
- Re-run full detection after each attempt.
```
You MUST NOT skip unchanged files (partial detection forbidden).

#### 7A.7.7 Reporting Template Snapshot (Second-Person)
Example MUST include placeholders for: `run_id`, `instruction_format_version`, `agent_name`, `agent_model`, `token_estimate_method`, `execution_state`, `constraints[...]`, `summary`, final `execution_state` after validation.
Key ordering MUST remain stable; absent keys are schema violations.

#### 7A.7.8 Outcome Actions (Second-Person)
Outcome table with rows: SUCCESS / PARTIAL / INCOMPLETE mapping to mandatory follow-up actions (commit proposal, beads creation, escalation). Language MUST forbid declaring success if any remaining violations exist.

#### 7A.7.9 Escalation & Beads Integration (Second-Person)
Beads title template: `Constraint <id> remaining violations after run <run_id>`.
Must reference parent via dependency `discovered-from:<run_id>` when supported.

#### 7A.7.10 Token / Complexity Management (Second-Person)
Heuristic guidance: If `approx_token_length` > configured `max_length`, split by criticality (High first), preserve `run_id` lineage across segments.

#### 7A.7.11 Non-Interpretation Principle Reminder (Second-Person)
Explicit statement forbidding treating example statuses as factual prior to loop completion.

#### 7A.7.12 Forbidden Shortcuts List (Second-Person)
Items (verbatim semantics): skipping detection steps, declaring success after partial remediation, fabricating remediation attempts, deleting violations without code change.

#### 7A.7.13 Version Linkage Block (Second-Person)
Mandate re-running `cda validate` if `instruction_format_version` mismatch is detected.

#### 7A.7.14 Checklist Block (Second-Person)
Numbered list of exactly 10 items culminating in setting `execution_state` and preparing final report.

#### 7A.7.15 Future Enhancements (Informative)
List is informational only; MUST mark as non-binding.

#### 7A.7.16 Final Mandatory Reminder
Closing sentence MUST read: “All instructions herein are mandatory for you unless explicitly marked Informative. Failure to follow any MUST invalidates your validation report.” 

---

### 7A.8 Compliance Verification for Generated `CDA.md`
Future enhancement: CDA may parse the generated `CDA.md` to ensure every required second-person heading/block exists. Absence or third-person phrasing for mandatory imperatives would be flagged as an initialization warning.

### 7A.9 Non-Goals for `CDA.md` Content (Clarification)
`CDA.md` MUST NOT embed dynamic run metadata (e.g., live violation counts). It is a static playbook addressed to you; dynamic data belongs in your execution reports.

### 7A.10 Security Boundaries in `CDA.md`
You MUST avoid exposing sensitive code beyond what is necessary for detection. Example excerpts SHOULD be minimal and generic.

---

Schema Highlights (informal MVP):
- `default`: optional; falls back to `copilot` if present.
- `agents`: map of agent name → definition.
- `command`: executable to spawn.
- `args`: array of static arguments.
- `mode`: one of `stdin` or `arg` in MVP; `file` support is deferred.
- `prompt_preamble`: text prepended before instruction package.
- `postscript`: appended after instruction package.
- `prompt_arg_flag`: optional override for the inline argument flag (defaults to `-p`).
- `prompt_file_arg`: optional override for the fallback flag when CDA writes the prompt to disk (defaults to `--prompt-file`).
- `max_length`: abort if assembled prompt length exceeds this.

## 8. Prompt Assembly Algorithm
1. Generate instruction package (batch or single) using existing formatters.
2. Collect components:
   - Header: `### CDA VERIFICATION PROMPT (DO NOT ASSUME COMPLIANCE)`
   - Run metadata: `run_id`, `instruction_format_version`, timestamp.
   - Preamble (from config) if provided.
   - Raw instruction package (unaltered).
   - Directive block: A static guidance reminding to fill report template exactly.
   - Postscript (from config) if provided.
3. Join with double newlines.
4. Validate length ≤ `max_length` (if defined).

## 9. Execution Flow (MVP - stdin + arg modes)
1. Resolve agent definition.
2. Build prompt string.
3. If `--output`, write file before execution.
4. If `--dry-run` or `--no-exec`, print prompt (and command unless `--no-exec`) then exit 0.
5. Spawn child process: `command` + `args`, applying mode rules:
   - `stdin`: pipe prompt to stdin.
   - `arg`: append `prompt_arg_flag` (default `-p`) then the entire prompt as a single argument. On Windows, estimate the resulting command length; if it exceeds ~8K characters, write the prompt to `%TEMP%/cda-agent-prompt-<run_id>.txt`, swap in `prompt_file_arg <path>` (default `--prompt-file`), surface the chosen file path in dry-run output, and delete the temp file after execution.
6. Pipe prompt to stdin only when mode is `stdin`; skip piping for `arg`.
7. Stream child stdout/stderr directly to parent terminal.
8. On spawn error (ENOENT etc.): print CDA error and set non-zero exit code.
9. Do not alter exit code based on child result (unless spawn failure).

## 10. Failure Modes & Error Messages
| Scenario | Handling | Message |
|----------|----------|---------|
| Missing config file | Graceful fallback | "No cda.agents.json found. Use --dry-run to inspect prompt or run `cda validate` instead." |
| Unknown agent name | Error | `CONFIG_ERROR: Unknown agent 'xyz'.` |
| Missing constraint id | Error | `CONFIG_ERROR: Unknown constraint 'id'.` |
| Prompt too long | Error | `CONFIG_ERROR: Prompt length N exceeds max_length M.` |
| External command not found | Error | `FATAL: Unable to spawn 'copilot'. Is the Copilot CLI installed?` |
| Unsupported mode value | Error | `CONFIG_ERROR: Unsupported agent mode 'file' (MVP provides 'stdin' and 'arg' only).` |

## 11. Security & Safety Considerations
- Do not send ignored paths or redacted secrets (future enhancement; MVP assumes instructions are safe).
- Avoid embedding repository secrets; rely on existing instruction package content only.
- Provide `--no-exec` to prevent accidental external calls when reviewing config.
- Document that external CLI invocation may transmit code context depending on further agent actions (out-of-scope for CDA).

## 12. Logging / Traceability (Optional)
- If `--output` omitted, optionally write last prompt to `.cda/last-agent-prompt.txt` for debugging.
- Include `run_id` and timestamp at top of prompt.

## 13. Future Extensions (Post-MVP)
1. Additional modes: `file` with placeholders.
2. Multi-agent chaining `--chain copilot,ollama`.
3. Structured output capture `--capture report.json`.
4. Light schema validation of returned report.
5. Redaction layer (`redact_patterns` in config).
6. Automatic fallback to secondary agent if primary fails.
7. Trust scoring & hash commitments of instruction blocks.

## 14. Acceptance Criteria (MVP)
- Running `cda agent --dry-run` prints assembled prompt (includes header, preamble, instruction package, directive block, postscript) and intended command line.
- Running `cda agent` with Copilot config streams Copilot CLI output without truncation.
- `--constraint <id>` uses single instruction package; `--sequential` works equivalently as in `validate`.
- Graceful message when `cda.agents.json` absent.
- Errors produce CDA error codes (consistent with existing error module) and non-zero exit status.
- Prompt length check enforced if `max_length` specified.
- Windows arg-mode fallback engages automatically when inline prompts exceed ~8K characters on Windows; dry-run output must show the `--prompt-file <path>` invocation and execution must clean up the temp file afterward.
- `cda init` creates `cda.config.json`, `CDA.md` and (if absent) `cda.agents.json` with `copilot` + `echo` agents.
- `cda init --no-agents` skips agent config creation while still generating `cda.config.json` and `CDA.md`.
- Existing `cda.agents.json` triggers skip notice without modification.

## 15. Decisions Incorporated (Updated)
1. Config file path: Project root `cda.agents.json` ONLY for MVP (no fallback search yet).
2. Last prompt file: Only written when `--output` is provided; no automatic write.
3. Default model (MVP Copilot): Configurable; sample uses GPT-5 placeholder. CDA does not validate real model availability.
4. Environment variable substitution: Deferred (post-MVP). Keep literal strings now.
5. Dry-run token estimate recommendation: Display two metrics:
  - `original_char_count: <chars>`
  - `approx_token_length: <Math.floor(chars / 4)>` (simple heuristic, model-agnostic). Rationale: fast, no dependency. Future: optional pluggable tokenizer.
6. Echo agent: Requires explicit entry in `cda.agents.json`. Acts exactly like other agents but just prints prompt (e.g., `command: "echo"`, `mode: "stdin"`). Auto-generated by `cda init` unless `--no-agents` or file exists.
7. Instruction adjustment when using agent command: Add banner `AGENT VERIFICATION MODE: PROMPT INTENDED FOR AUTOMATED EXECUTION` and avoid duplicating AGENT ACTION REQUIRED block.
8. No fallback to `.cda/agents.json` in MVP; documented as future extension only.
9. Windows arg-mode fallback: When the inline command would exceed ~8K characters, CDA writes the prompt to `%TEMP%/cda-agent-prompt-<run_id>.txt`, swaps in `prompt_file_arg <path>` (default `--prompt-file`), surfaces the chosen path in dry-run output, and deletes the temp file after execution.

## 16. Implementation Plan (Summary)
1. Add new command module `src/cli/commands/agent.ts`.
2. Add config loader utility (synchronous read & parse with minimal validation).
3. Reuse `validate` logic to build instruction package; avoid duplicate formatting code.
4. Assemble prompt components per algorithm.
5. Implement execution path (stdin + arg modes) & flags.
6. Add tests for: missing config, dry-run output structure, single vs batch prompt diff, max_length exceeded.
7. Add README section summarizing usage + sample config.
8. Release under new version (minor bump).

## 17. Risks & Mitigations
- Copilot CLI may change flags; we currently target the standalone `copilot` CLI (`copilot --model <model> --allow-all-tools -p "<prompt>"`).
- Large instruction packages could exceed model token limits; length check mitigates.
- Users may expect automatic parsing; explicit spec statements must manage expectations.

## 18. Glossary & Instruction Adjustment Notes (Expanded)
Glossary additions:
- `Verification Prompt`: Wrapped instruction package + directives formed by `cda agent`.
- `Agent Config`: JSON definition describing how to invoke external AI CLI.
- `Agent Execution Mode`: The invocation strategy (stdin or arg in MVP; future file streaming).
- `Echo Agent`: A non-AI local passthrough used to test prompt assembly.

-Instruction Adjustments in Agent Mode:
- Prepend: `AGENT VERIFICATION MODE: PROMPT INTENDED FOR AUTOMATED EXECUTION`.
- Retain original sentinel sections but DO NOT replicate the AGENT ACTION REQUIRED block twice; agent wrapper will include it only once before the raw instruction package.
- Append:
  - `original_char_count: <number>`
  - `approx_token_length: <number>` (chars / 4 heuristic)
- Include selected agent name: `agent_name: <configured>`.
- Include model hint if present: `agent_model: <value>`.
- Include note: `token_estimate_method: heuristic_chars_div_4`.

## 20. Backward Compatibility & Versioning
The standard `cda validate` output remains unchanged. Agent mode introduces a banner and metadata but leaves legacy formatting intact. The `--legacy-format` flag suppresses agent-mode additions (banner, advanced report template fields) to support toolchains expecting pre-update structure. Any future structural change MUST increment a minor version and add a README "Spec Changes" entry.

---
Assumptions consolidated in section 15. Deviations MUST trigger a minor version bump and an added compatibility note in README under "Spec Changes".

## 19. AI Agent Consumption Guidelines
These guidelines ensure consistent, machine-readable ingestion by autonomous AI agents:

### 19.1 Stable Sentinels & Ordering
- Banner always first line in agent mode: `AGENT VERIFICATION MODE: PROMPT INTENDED FOR AUTOMATED EXECUTION`.
- Token estimation lines always appear AFTER the instruction package and BEFORE any postscript.
- Order (agent mode): Banner → Metadata block → Optional preamble → Raw instruction package → Directive block → Postscript → Metrics lines (char + token heuristic).

### 19.2 Required Fields For Agents
Agents MUST NOT assume analysis occurred unless `execution_state: validated` appears in a future workflow. In the initial prompt it is always `unvalidated`.
Agents SHOULD echo back:
- `run_id`
- `instruction_format_version`
- `agent_name`
- `agent_model` (if provided)
- `approx_token_length` (for traceability)

### 19.3 Non-Interpretation Principle
If any field suggests current compliance (e.g., `no_remaining_violations: true`) while `execution_state: unvalidated`, agent MUST treat it as a TEMPLATE FIELD ONLY, not factual state.

### 19.4 Report Generation Rules (Restated Concisely)
1. Enumerate all constraints listed; do not omit even if zero violations.
2. Populate empty arrays explicitly (e.g., `violations: []`).
3. Record initial violations before attempting fixes.
4. Attempt remediation strictly in provided fix strategy order.
5. Re-run detection steps (up to documented attempts) before declaring success.
6. Set `execution_state: validated` only after full cycle completion; else `failed` if remaining violations > 0.

### 19.5 Ambiguity Safeguards
- Any missing key in final report constitutes schema non-conformance.
- Agents must not fabricate file paths; only use discovered enumerated files.
- Agents must include disputed violation reasoning instead of deletion.

### 19.6 Extensibility Contracts
Future fields may be appended under a clearly named block (e.g., `audit_trace:`) but existing keys will not be repurposed.

### 19.7 Machine Parsing Recommendations
Downstream automated parsers should:
- Treat lines with `key: value` format as canonical KV pairs until a block header starts (e.g., `summary:`).
- Consider indentation (
  two spaces) as block nesting indicator.
- Use regex anchors to detect sentinel boundaries: `^===== BEGIN CDA INSTRUCTIONS.*` and `^===== END CDA INSTRUCTIONS.*`.

### 19.8 Failure Classification
Agents should classify run outcomes:
- SUCCESS: All constraints evaluated, zero remaining violations.
- PARTIAL: All constraints evaluated, some remaining violations.
- INCOMPLETE: Not all constraints evaluated (missing block execution) or early termination.

### 19.9 Echo Agent Behavior
Echo agent simply returns the prompt unchanged; downstream logic MUST NOT treat this as evaluation.

### 19.10 Security Reminder For Agents
Do not transmit repository contents beyond what is required to fulfill detection steps; minimize extraneous code excerpts in generated report.

